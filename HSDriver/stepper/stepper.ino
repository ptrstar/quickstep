// CNC Shield V3 pin definitions
#define X_STEP 2
#define X_DIR  5
#define Y_STEP 3
#define Y_DIR  6
#define Z_STEP 4
#define Z_DIR  7
#define ENABLE_PIN 8

#define X_MICROSTEPS 8
#define Y_MICROSTEPS 8
#define Z_MICROSTEPS 8

#define LIFT_AMT 20
#define MAX_SPEED 50 // steps per second

// PROGRAM

const uint8_t IM[] PROGMEM = {
0x8A,0x10,0x62,0x10,0x63,0x00,0x29,
0xAA,0xfb,0x00,0x00,0xed,0xee,0x00,0x00,0x13,
0xAA,0xfb,0x00,0x00,0xd7,0x05,0x00,0x00,0x12,
0x2A,0x12,0x00,0x00,0xee,0x05,0x00,
0xA1,0x66,0x76,
0xAA,0x76,0x76,0x76,0x76,
0xA8,0x0a,0xff,0xe0,
0xAA,0x1e,0x2e,0x0d,0x1e,
0xAA,0xfb,0xed,0xdd,0xd0,
0xAA,0xb1,0xd3,0xe4,0x06,
0xAA,0x06,0xd0,0xe0,0xee,
0xAA,0xfe,0x0d,0x0d,0x1e,
0xAA,0x1e,0x20,0x0a,0xd1,
0xAA,0xd3,0xe4,0xf5,0x15,
0xAA,0x24,0x33,0x40,0x50,
0xAA,0x50,0x50,0x31,0x31,
0xA8,0xea,0xfb,0xfb,
0xA8,0x03,0xf3,0xe2,
0xAA,0xf1,0x90,0x0b,0x29,
0xAA,0x4d,0x20,0x22,0x12,
0x52,0x02,
0xA2,0x1a,0xde,0x00,0xfb,0x10,0x00,
0xAA,0x00,0x27,0x0b,0x00,0x00,0x04,0xe5,0x00,
0xAA,0x00,0xfc,0x0b,0x00,0x00,0xde,0xf5,0x00,
0x88,0x24,0x00,0x00,0xfb,
0xAA,0x10,0x00,0x00,0x27,0x0b,0x00,0x00,0x04,
0xAA,0xe5,0x00,0x00,0xfc,0x0b,0x00,0x00,0xde,
0x12,0xf5,0x00,
0xAA,0x46,0x47,0x57,0x57,
0xA2,0x57,0xa1,0xb2,
0xAA,0xd5,0xe6,0x26,0x35,
0xAA,0x52,0x61,0x6f,0x5e,
0xAA,0x3b,0x2a,0xea,0xdb,
0x8A,0xbe,0xaf,0x05,
0xA8,0x51,0x31,0x33,
0xAA,0x04,0x04,0xd3,0xd1,
0xAA,0xb1,0xbf,0xdf,0xdd,
0xAA,0x0c,0x0c,0x3d,0x3f,
0x52,0x5f,
0xA2,0x54,0xe6,0x05,0x1e,0x04,0xe2,
0xAA,0x05,0x00,0xfa,0x29,0xfb,0x00,0xfa,0xe1,
0xAA,0xfb,0x1f,0xfa,0x00,0xfb,0xd7,0x05,0x00,
0x2A,0x04,0x1e,0x05,0xe2,0x05,0x00,
0xA1,0x75,0x75,
0xAA,0x76,0x76,0x76,0x76,
0xA8,0xfa,0xdb,0xbd,
0xAA,0xaf,0xf0,0x91,0xb3,
0xAA,0xd5,0xf5,0x16,0x45,
0xAA,0x42,0x61,0x20,0x0a,
0xAA,0x0a,0x0a,0x0b,0x41,
0xAA,0x42,0x23,0x04,0xf6,
0xAA,0xd3,0x34,0x2e,0x2d,
0x8A,0x1c,0x1c,0x9f,
0x2A,0x90,0x90,0xa0,
0xAA,0x0d,0x2e,0x3e,0x3f,
0xAA,0x05,0x06,0x06,0xdf,
0x2A,0xdf,0xed,0x0c,
0x25,0x18,0xf4,
0xAA,0x00,0xfb,0x10,0x00,0x00,0x27,0x0b,0x00,
0xAA,0x00,0x04,0xe5,0x00,0x00,0xfc,0x0b,0x00,
0x4A,0x00,0xde,0xf5,0x00,
0xA8,0x06,0x06,0x06,
0xAA,0x06,0x06,0x06,0x17,
0xA8,0x05,0x70,0x06,
0xAA,0x06,0x40,0x0a,0x0a,
0xAA,0x50,0x50,0x60,0x30,
0xAA,0x22,0x12,0x02,0x02,
0xAA,0x02,0x01,0xf1,0x41,
0xAA,0x1f,0x0e,0x1d,0x0e,
0xAA,0xfc,0xec,0xde,0xb0,
0xAA,0xa0,0xb0,0xb0,0x0b,
0xAA,0x0c,0xc0,0x04,0x05,
0xA2,0x90,0xb9,0xb9,
0xAA,0xb9,0xb9,0xb9,0xc9,
0xAA,0xc9,0xc9,0xc9,0xc9,
0xAA,0xc9,0xc9,0xc9,0xc9,
0xAA,0xc9,0xc9,0xc9,0xc9,
0xAA,0xc9,0xc9,0xc9,0xc9,
0xAA,0xc9,0xc9,0xc9,0xc9,
0xAA,0xc9,0xc9,0xc9,0xc9,
0xAA,0xc9,0xc9,0xc9,0xc9,
0xAA,0xc9,0xc9,0xc9,0xc9,
0xAA,0xc9,0xc9,0xc9,0xc9,
0xAA,0xc9,0xca,0xca,0xca,
0xEA,0xca,0xca,0xca,

};

uint16_t IP = 0;
uint8_t printhead_down = 0;
uint8_t instr_buffer = 0;
uint8_t instr_buffer_index = 0;
uint8_t data_size = 0x08; // amt of bits used per data point, 0: 4 bit signed ints, 1: (default) 8 bit signed ints, 2: 16 bit signed ints

void setup() {
  pinMode(X_STEP, OUTPUT); 
  pinMode(X_DIR, OUTPUT);  
  pinMode(Y_STEP, OUTPUT); 
  pinMode(Y_DIR, OUTPUT);  
  pinMode(Z_STEP, OUTPUT); 
  pinMode(Z_DIR, OUTPUT);  

  pinMode(ENABLE_PIN, OUTPUT);

  digitalWrite(X_DIR, LOW);
  digitalWrite(Y_DIR, LOW);
  digitalWrite(Z_DIR, LOW);

  digitalWrite(X_STEP, LOW);
  digitalWrite(Y_STEP, LOW);
  digitalWrite(Z_STEP, LOW);

  digitalWrite(ENABLE_PIN, LOW);

  // Serial.begin(9600);
  while (!Serial);
  delay(1500);
  // Serial.println("START");
}

uint8_t fetch_instr() {
  // load new instruction
  if (instr_buffer_index == 0) {
    instr_buffer = pgm_read_byte(&IM[IP]);
    IP++;
    instr_buffer_index = 4; 
  }
  uint8_t mask = 0x03;
  uint8_t instr = mask & instr_buffer;
  instr_buffer = instr_buffer >> 2;
  instr_buffer_index--;

  return instr;
}

// MAIN: load and execute next instruction, synchronous
void loop() {

  uint8_t instr = fetch_instr();

  switch(instr) {
    case 0x00:
      i_toggle_printhead();
      break;
    case 0x01:
      i_set_datasize();
      break;
    case 0x02:
      i_move();
      break;
    case 0x03:
      i_exit();
      break;
  }
}

// HELPER: Set the driving pins high and low for 2 microseconds, synchronous
void drive(int pin) {
  digitalWrite(pin, HIGH);
  delayMicroseconds(2);
  digitalWrite(pin, LOW);
}

// INSTRUCTION: toggle printhead
void i_toggle_printhead() {
  if (printhead_down) {
    digitalWrite(Z_DIR, LOW);
  } else {
    digitalWrite(Z_DIR, HIGH);
  }
  printhead_down = !printhead_down;
  for (uint8_t i = 0; i < LIFT_AMT * Z_MICROSTEPS; i++) {
    drive(Z_STEP);
    delay(max(2, 1000/MAX_SPEED));
  }
}

// INSTRUCTION: set datasize
void i_set_datasize() {
  // set data_size to 0x04, 0x08 or 0x10 respectively
  data_size = 0x04 << fetch_instr();
}

// INSTRUCTION: move 
void i_move() {
  
  // Load coordinates according to datasize
  uint32_t yx;
  switch (data_size) {
    case 0x04:
      yx = pgm_read_byte(&IM[IP]);
      IP++;
      break;
    case 0x08:
      yx = pgm_read_word(&IM[IP]);
      IP += 2;
      break;
    case 0x10:
      yx = pgm_read_dword(&IM[IP]);
      IP += 4;
      break;
  }

  // read data_size many bits for both x and y
  int32_t readY = (yx >> data_size);
  int32_t readX = (yx & (((uint32_t)1 << data_size)-1));

  // extend negative numbers eg. for data size = 4
  // readY = ...00001000 as msb is 1 we need to extend to
  // readY = ...11111000 to retain the same value
  if (readY & ((uint32_t)1 << (data_size-1))) {
    readY = readY | ~(((uint32_t)1 << data_size)-1);
  }
  if (readX & ((uint32_t)1 << (data_size-1))) {
    readX = readX | ~(((uint32_t)1 << data_size)-1);
  }

  // set direction
  digitalWrite(X_DIR, (readX < 0) ? LOW : HIGH);
  digitalWrite(Y_DIR, (readY < 0) ? LOW : HIGH);

  // driver
  uint32_t tarX = abs(readX);
  uint32_t tarY = abs(readY);
  uint64_t posX = 0;
  uint64_t posY = 0;
  uint64_t current_time;

  uint32_t dist = sqrt(sq(tarX) + sq(tarY));
  uint64_t duration = 1000000 * dist / MAX_SPEED; // in millis

  uint32_t start_time = micros();
  uint32_t wait;

  uint64_t mtX = tarX * X_MICROSTEPS;
  uint64_t mtY = tarY * Y_MICROSTEPS;

  // main synchronous move block
  while (posX != mtX || posY != mtY) {
    current_time = micros() - start_time;
    wait = 0;

    uint64_t stepX = mtX * current_time / duration;
    uint64_t stepY = mtY * current_time / duration;

    if (stepX > posX) {
      drive(X_STEP);
      posX++;
      wait = 1;
    }
    if (stepY > posY) {
      drive(Y_STEP);
      posY++;
      wait = 1;
    }

    if (wait) {delayMicroseconds(500);}
  }
}

// INSTRUCTION: terminate
void i_exit() {
  // Serial.println("i_exit()");
  digitalWrite(ENABLE_PIN, HIGH);
  while(true);
}