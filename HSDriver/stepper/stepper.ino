// CNC Shield V3 pin definitions
#define X_STEP 2
#define X_DIR  5
#define Y_STEP 3
#define Y_DIR  6
#define Z_STEP 4
#define Z_DIR  7
#define ENABLE_PIN 8

#define X_MICROSTEPS 8
#define Y_MICROSTEPS 8
#define Z_MICROSTEPS 8

#define LIFT_AMT 20

#define MAX_SPEED 50 // steps per second

const uint8_t IM[] PROGMEM = {
0xA1,0x56,0x66,
0xAA,0x66,0x66,0x67,0x67,
0xAA,0x67,0x67,0x67,0x67,
0xAA,0x67,0x67,0x67,0x67,
0xAA,0x67,0x67,0x67,0x67,
0xAA,0x67,0x67,0x67,0x67,
0xA8,0x05,0x15,0xf3,
0x88,0xb2,0x03,
0xAA,0xd4,0xe4,0xe5,0xf5,
0x4A,0xd7,0xd7,
0x89,0x03,0x00,0x1a,0x00,
0xAA,0x14,0x05,0x0f,0x00,0x14,0x03,0x0f,0x07,
0xAA,0x0a,0x05,0x20,0x1d,0x04,0x07,0xfe,0x0e,
0x8A,0x00,0x01,0x00,0x03,0xf8,0x02,
0xA8,0x00,0x1e,0xfc,0x15,0x02,0x0c,
0xAA,0xf6,0x1d,0x02,0x10,0xfc,0x0f,0xf3,0x1c,
0x2A,0xfe,0x0c,0xf8,0x17,0x00,0x02,
0xA2,0xfd,0x07,0x13,0x05,0x07,0x02,
0xAA,0x04,0x06,0xfe,0x08,0xf7,0x09,0xff,0x07,
0x2A,0x05,0x0f,0xfd,0x0d,0x00,0x02,
0x21,0x0b,
0xAA,0x5f,0x60,0xf5,0x06,
0x88,0x0b,0x0f,
0x22,0x0f,0xb5,
0xA8,0x9e,0xae,0xaf,
0x28,0x0d,0x0e,
0xA2,0x92,0xfe,0xed,
0x8,0x7b,
0x25,0x00,0x05,
0xAA,0xff,0xfe,0xfd,0xfe,0xf4,0xfd,0xe8,0x00,
0x84,0x16,
0x8A,0x26,0x26,0x2f,
0x22,0x21,0xc2,
0x88,0x73,0x41,
0xAA,0x07,0xc4,0x09,0x0d,
0x8,0xb5,
0xA,0x5b,0x5b,
0x25,0x1c,0xe1,
0xAA,0xf7,0x05,0xc1,0x02,0xf9,0x02,0xfa,0x06,
0x12,0x00,0x0c,
0x2A,0xa0,0xa1,0xa1,
0x94,0x26,0xeb,
0xA8,0x02,0x00,0x1d,0xfd,0x15,0xfe,
0x84,0x61,
0x82,0x62,0x9b,
0x8A,0xab,0xab,0x0e,
0x22,0x0f,0x0e,
0x2A,0x1c,0x2c,0x2e,
0x2A,0xb1,0xb2,0xb2,
0xAA,0x3b,0x3c,0x0a,0x0b,
0x4A,0x1b,0x0d,
0x89,0x0d,0xf5,0xfd,0x00,
0xAA,0xf5,0x04,0xf8,0x03,0xf4,0x00,0xf3,0xfa,
0xAA,0xdd,0xe6,0xea,0xee,0xee,0xf9,0xfa,0xf8,
0x84,0xe5,
0x28,0x24,0x31,
0x8A,0x05,0x05,0xbe,
0x22,0xe0,0xdb,
0x4A,0xe0,0x90,
0x89,0xf8,0x00,0xf0,0x04,
0xAA,0xf8,0x04,0xf6,0x0e,0xff,0x0f,0x02,0x09,
0xAA,0xf9,0x07,0xf9,0x13,0xfe,0x08,0xf9,0x04,
0xAA,0xf6,0x04,0xf8,0x08,0xf1,0x16,0xee,0x15,
0x84,0x95,
0xAA,0x95,0x95,0x95,0x95,
0xAA,0x95,0x95,0x95,0x95,
0xAA,0x95,0x95,0x95,0x95,
0xAA,0xa5,0xa5,0xa5,0xa5,
0x8A,0xa5,0xa5,0xf0,
0xA2,0xe0,0xeb,0xeb,
0xA0,0xb0,0xb1,
0x82,0xb1,0x90,
0xA8,0x62,0x46,0x22,
0x28,0xc5,0xd5,
0xAA,0xdf,0xff,0xbe,0xbf,
0x28,0xbb,0xbb,
0x2A,0xe1,0xc0,0xad,
0xA2,0x0d,0x4e,0x4e,
0x8A,0x6f,0x30,0xa1,
0x82,0xa2,0xb0,
0xA2,0xb0,0xfd,0xfe,
0x94,0xfb,0xf6,
0xA8,0xfd,0x1c,0x04,0x0e,0x03,0x06,
0x12,0x01,0x02,
0xAA,0x16,0x16,0x26,0x26,
0x82,0x26,0x26,
0xA2,0x26,0xef,0xed,
0xAA,0xfb,0x0b,0xd9,0x9a,
0xAA,0x9d,0xc2,0xc4,0xd4,
0x52,0xbb,
0xA2,0x00,0xf9,0x01,0xff,0xfb,0xfb,
0xAA,0xf1,0xf2,0xff,0xf9,0xfb,0xe8,0x00,0xe8,
0xAA,0x04,0xf4,0x07,0xf7,0x03,0xf6,0x10,0xee,
0x84,0xb5,
0x82,0xc5,0x51,
0x8A,0x51,0x61,0x30,
0x22,0x52,0x20,
0x2A,0x14,0x14,0x02,
0xA2,0x05,0x1f,0x15,
0xAA,0xe7,0xd4,0xbf,0xaa,
0x8,0x57,
0x2A,0xaf,0xaf,0xb0,
0x2A,0x02,0xe4,0xb1,
0xA2,0x75,0x23,0xf3,
0x2A,0xe5,0xe6,0xe6,
0x82,0x02,0x51,
0x8A,0x62,0x62,0xf3,
0x8A,0xa6,0xb6,0x03,
0xA0,0x65,0x65,
0x28,0xb5,0x02,
0x2A,0x45,0x45,0x45,
0xAA,0x3b,0x3c,0x1d,0x0d,
0xA8,0xd6,0xe6,0xe6,
0x28,0x05,0x02,
0xA2,0xe5,0x31,0x47,
0x2A,0x50,0x50,0x20,
0x8A,0x2b,0x3b,0x35,
0xAA,0x54,0x64,0x64,0x43,
0x22,0x20,0xd5,
0x88,0xe5,0x40,
0xA2,0x12,0x2b,0x3b,
0xA8,0x62,0x7e,0x41,
0x2A,0x52,0x6d,0x3e,
0x8A,0x7d,0x7e,0x05,
0x8A,0x05,0x02,0x0b,
0x8A,0x0b,0x0b,0x3b,
0x52,0x2e,
0xA2,0xfb,0x00,0xfd,0x20,0x03,0x0e,
0x8A,0xff,0x04,0xfe,0x02,0x05,0x02,
0xA8,0xfa,0x05,0xe8,0xfe,0xfe,0x00,
0x84,0x1b,
0xA2,0x1b,0x15,0x66,
0xAA,0x27,0x34,0x44,0x44,
0x22,0x20,0xd5,
0x8A,0x11,0x21,0x24,
0xA2,0x24,0xe0,0x9f,
0x8A,0xaf,0xaf,0xba,
0x8A,0xba,0xcb,0xd0,
0xAA,0xcf,0xcf,0x93,0x91,
0x2A,0x9e,0x9e,0x9f,
0x82,0xc0,0xbe,
0x28,0xfe,0xef,
0x8A,0x15,0x25,0x4f,
0xAA,0x2a,0x2a,0x2a,0x1f,
0x22,0x1e,0x9b,
0x8A,0xee,0xff,0x1b,
0xA2,0x2b,0x45,0x46,
0xAA,0x53,0x4f,0x19,0x19,
0x2A,0xd9,0xe9,0xee,
0x8A,0xc1,0xc1,0x0e,
0xAA,0x1b,0x2c,0xeb,0xfc,
0x28,0xe6,0xe7,
0x8A,0xd0,0xb5,0x02,
0x20,0x53,
0x8A,0x02,0xe5,0x03,
0x20,0x72,
0x2A,0x2e,0x29,0xca,
0x42,0x99,
0x89,0xf1,0xf9,0x02,0x00,
0x8A,0x09,0xfd,0x1f,0xfe,0x03,0x00,
0xA8,0x1a,0x04,0x0f,0xfe,0x04,0x01,
0x12,0x02,0x02,
0x2A,0x74,0x74,0x75,
0x2A,0x7c,0x2a,0xed,
0xA,0xf5,0xf5,
0xA2,0x05,0x23,0x32,
0xA8,0xf9,0xf9,0xf9,
0xAA,0xf9,0xf9,0xf9,0xf9,
0x2A,0xfa,0xfa,0xfa,
0x8A,0xf0,0xf0,0x9f,
0xAA,0x9f,0x9f,0x9f,0x9f,
0xAA,0xaf,0xaf,0xaf,0xaf,
0xA2,0xaf,0x02,0xf5,
0x52,0xf5,
0xA2,0xf9,0xfb,0xfd,0x02,0xfa,0x02,
0x4A,0xf6,0xff,0xe8,0xfd,
0x88,0x93,0xed,
0x22,0xbe,0x2b,
0x8A,0x3d,0x2e,0x5d,
0x50,
0xA2,0xfb,0x00,0xfc,0x08,0x04,0x0a,
0xAA,0xf5,0x15,0x01,0x0a,0xfe,0x1c,0x03,0x0c,
0x2A,0x0a,0x0a,0x03,0x03,0x01,0x03,
0xA1,0x9a,0xaa,
0x2A,0xaa,0xaa,0xaa,
0xAA,0xdf,0xcd,0xb9,0xd9,
0x8A,0xea,0xea,0x55,
0xA,0x55,0x65,
0xAA,0x93,0x93,0xa3,0xa3,
0x8A,0xa3,0xa3,0xe0,
0xAA,0xaf,0xb0,0x94,0xd4,
0xA2,0xd5,0xe9,0xf9,
0x8A,0xf9,0xfa,0xe0,
0xAA,0xb0,0xd6,0xf5,0xf5,
0xAA,0xe6,0xe6,0xd6,0xe6,
0x88,0x02,0xf7,
0xAA,0xf7,0x07,0x93,0xf1,
0xA2,0x03,0x52,0x62,
0xA2,0x63,0xca,0x3d,
0x2A,0x53,0x24,0x12,
0xA2,0x05,0xe0,0xd0,
0x94,0x14,0x08,
0xA8,0x18,0x04,0x0b,0xfe,0x03,0x00,
0x84,0xb2,
0xA8,0xe2,0xff,0xa4,
0x88,0x29,0x2a,
0xAA,0x3a,0xea,0xfb,0x0e,
0xA8,0xd6,0xd6,0xd6,
0xAA,0xd6,0xd6,0xe6,0xe7,
0xA2,0xe7,0x01,0x01,
0xA8,0x06,0x17,0x17,
0xA0,0x50,0x50,
0xA2,0x50,0x40,0x50,
0x52,0x30,
0x8A,0xd4,0x4d,0xd5,0x4d,0x24,0x00,
0xAA,0x0c,0x05,0x03,0x04,0xfd,0x03,0xea,0xfe,
0x2A,0xe9,0xfd,0xfd,0x00,0xfd,0xfe,
0xA1,0x35,0x36,
0x8A,0x36,0x36,0x05,
0xAA,0x05,0x06,0x24,0x35,
0x52,0x22,
0xA2,0x00,0x0a,0xfe,0x00,0xfc,0x01,
0x4A,0xf6,0xff,0xde,0xfd,
0xA8,0xc9,0xc9,0xd9,
0xAA,0xd9,0xd9,0xd9,0xd9,
0xAA,0xd9,0xd9,0xda,0xda,
0x28,0xe0,0xf0,
0xAA,0x9e,0x9e,0x9e,0x9e,
0xAA,0x9e,0x9e,0x9f,0x9f,
0xAA,0x9f,0x9f,0x9f,0x9f,
0xAA,0x9f,0x9f,0x9f,0x9f,
0xAA,0x9f,0x9f,0x9f,0x9f,
0xAA,0x9f,0x9f,0x9f,0x9f,
0xA,0x9f,0xaf,
0xAA,0x99,0x99,0x99,0x99,
0xAA,0x99,0x99,0x99,0x99,
0xAA,0x99,0x99,0x99,0x99,
0xAA,0x9a,0x9a,0x9a,0x9a,
0xAA,0x9a,0x9a,0x9a,0xaa,
0xE,0xaa,

};
// const uint8_t IM[] PROGMEM = {
// // 0xe1, 0x2F // size4: Y X
// // 0xe5, 0xfe, 0x7f // size8: X Y
// 0xe9, 0xFF,0xFF, 0x02,0x00 // size16: X Y what the heck. check little endianness!!! -1, 2


// };

uint16_t IP = 0;
uint8_t printhead_down = 0;
uint8_t instr_buffer = 0;
uint8_t instr_buffer_index = 0;
uint8_t data_size = 0x08; // amt of bits used per data point, 0: 4 bit signed ints, 1: (default) 8 bit signed ints, 2: 16 bit signed ints

void setup() {
  pinMode(X_STEP, OUTPUT); 
  pinMode(X_DIR, OUTPUT);  
  pinMode(Y_STEP, OUTPUT); 
  pinMode(Y_DIR, OUTPUT);  
  pinMode(Z_STEP, OUTPUT); 
  pinMode(Z_DIR, OUTPUT);  

  pinMode(ENABLE_PIN, OUTPUT);

  digitalWrite(X_DIR, LOW);
  digitalWrite(Y_DIR, LOW);
  digitalWrite(Z_DIR, LOW);

  digitalWrite(X_STEP, LOW);
  digitalWrite(Y_STEP, LOW);
  digitalWrite(Z_STEP, LOW);

  digitalWrite(ENABLE_PIN, LOW);

  // Serial.begin(9600);
  while (!Serial);
  delay(1500);
  // Serial.println("START");
}

uint8_t fetch_instr() {
  // load new instruction
  if (instr_buffer_index == 0) {
    instr_buffer = pgm_read_byte(&IM[IP]);
    IP++;
    instr_buffer_index = 4; 
  }
  uint8_t mask = 0x03;
  uint8_t instr = mask & instr_buffer;
  instr_buffer = instr_buffer >> 2;
  instr_buffer_index--;

  return instr;
}

void loop() {

  // line is obsolete (and incorrect since dynamic intsize changes) as "0b11" ends the program
  // if (IP >= instrCount) return;

  uint8_t instr = fetch_instr();

  switch(instr) {
    case 0x00:
      i_toggle_printhead();
      break;
    case 0x01:
      i_set_datasize();
      break;
    case 0x02:
      i_move();
      break;
    case 0x03:
      i_exit();
      break;
  }
}
void drive(int pin) {
  digitalWrite(pin, HIGH);
  delayMicroseconds(2);
  digitalWrite(pin, LOW);
}

void i_toggle_printhead() {
  if (printhead_down) {
    digitalWrite(Z_DIR, LOW);
  } else {
    digitalWrite(Z_DIR, HIGH);
  }
  printhead_down = !printhead_down;
  for (uint8_t i = 0; i < LIFT_AMT * Z_MICROSTEPS; i++) {
    drive(Z_STEP);
    delay(3);
    // delay(max(2, 1000/MAX_SPEED));
  }
}

void i_set_datasize() {
  // set data_size to 0x04, 0x08 or 0x10 respectively
  data_size = 0x04 << fetch_instr();
}

void i_move() {
  
  uint32_t yx;

  switch (data_size) {
    case 0x04:
      yx = pgm_read_byte(&IM[IP]);
      IP++;
      break;
    case 0x08:
      yx = pgm_read_word(&IM[IP]);
      IP += 2;
      break;
    case 0x10:
      yx = pgm_read_dword(&IM[IP]);
      IP += 4;
      break;
  }

  // read data_size many bits for both x and y
  int32_t readY = (yx >> data_size);
  int32_t readX = (yx & (((uint32_t)1 << data_size)-1));

  // extend negative numbers eg. for data size = 4
  // readY = ...00001000 as msb is 1 we need to extend to
  // readY = ...11111000 to retain the same value
  if (readY & ((uint32_t)1 << (data_size-1))) {
    readY = readY | ~(((uint32_t)1 << data_size)-1);
  }
  if (readX & ((uint32_t)1 << (data_size-1))) {
    readX = readX | ~(((uint32_t)1 << data_size)-1);
  }

  // set direction
  digitalWrite(X_DIR, (readX < 0) ? LOW : HIGH);
  digitalWrite(Y_DIR, (readY < 0) ? LOW : HIGH);

  // driver
  uint32_t tarX = abs(readX);
  uint32_t tarY = abs(readY);
  uint64_t posX = 0;
  uint64_t posY = 0;
  uint64_t current_time;

  uint32_t dist = sqrt(sq(tarX) + sq(tarY));
  uint64_t duration = 1000000 * dist / MAX_SPEED; // in millis

  uint32_t start_time = micros();
  uint32_t wait;

  uint64_t mtX = tarX * X_MICROSTEPS;
  uint64_t mtY = tarY * Y_MICROSTEPS;

  while (posX != mtX || posY != mtY) {
    current_time = micros() - start_time;
    wait = 0;

    uint64_t stepX = mtX * current_time / duration;
    uint64_t stepY = mtY * current_time / duration;

    if (stepX > posX) {
      drive(X_STEP);
      posX++;
      wait = 1;
    }
    if (stepY > posY) {
      drive(Y_STEP);
      posY++;
      wait = 1;
    }

    if (wait) {delayMicroseconds(500);}
  }
}
void i_exit() {
  // Serial.println("i_exit()");
  digitalWrite(ENABLE_PIN, HIGH);
  while(true);
}